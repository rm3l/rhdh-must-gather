#!/bin/bash

# RHDH Resources Collection Script
# Collects all resources from the RHDH namespace

set -euo pipefail

# Source utilities
source "$(dirname "$0")/lib/utils.sh"

collect_all_namespace_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting all resources from RHDH namespace: $namespace"
    ensure_directory "$resources_dir"
    
    # Get all resources in the namespace
    safe_exec "kubectl get all -n '$namespace'" "$resources_dir/all-resources.txt" "All resources list"
    safe_exec "kubectl get all -n '$namespace' -o yaml" "$resources_dir/all-resources.yaml" "All resources details"
    safe_exec "kubectl describe all -n '$namespace'" "$resources_dir/all-resources-describe.txt" "All resource descriptions"
    
    # Get all resources with wide output for more details
    safe_exec "kubectl get all -n '$namespace' -o wide" "$resources_dir/all-resources-wide.txt" "All resources (wide output)"
}

collect_workload_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting workload resources..."
    
    local workloads_dir="$resources_dir/workloads"
    ensure_directory "$workloads_dir"
    
    # Deployments
    safe_exec "kubectl get deployments -n '$namespace'" "$workloads_dir/deployments.txt" "Deployments list"
    safe_exec "kubectl get deployments -n '$namespace' -o yaml" "$workloads_dir/deployments.yaml" "Deployments details"
    safe_exec "kubectl describe deployments -n '$namespace'" "$workloads_dir/deployments-describe.txt" "Deployment descriptions"
    
    # ReplicaSets
    safe_exec "kubectl get replicasets -n '$namespace'" "$workloads_dir/replicasets.txt" "ReplicaSets list"
    safe_exec "kubectl get replicasets -n '$namespace' -o yaml" "$workloads_dir/replicasets.yaml" "ReplicaSet details"
    
    # Pods
    safe_exec "kubectl get pods -n '$namespace'" "$workloads_dir/pods.txt" "Pods list"
    safe_exec "kubectl get pods -n '$namespace' -o yaml" "$workloads_dir/pods.yaml" "Pod details"
    safe_exec "kubectl describe pods -n '$namespace'" "$workloads_dir/pods-describe.txt" "Pod descriptions"
    safe_exec "kubectl get pods -n '$namespace' -o wide" "$workloads_dir/pods-wide.txt" "Pods (wide output)"
    
    # StatefulSets
    safe_exec "kubectl get statefulsets -n '$namespace'" "$workloads_dir/statefulsets.txt" "StatefulSets list"
    safe_exec "kubectl get statefulsets -n '$namespace' -o yaml" "$workloads_dir/statefulsets.yaml" "StatefulSet details"
    
    # DaemonSets
    safe_exec "kubectl get daemonsets -n '$namespace'" "$workloads_dir/daemonsets.txt" "DaemonSets list"
    safe_exec "kubectl get daemonsets -n '$namespace' -o yaml" "$workloads_dir/daemonsets.yaml" "DaemonSet details"
    
    # Jobs and CronJobs
    safe_exec "kubectl get jobs -n '$namespace'" "$workloads_dir/jobs.txt" "Jobs list"
    safe_exec "kubectl get jobs -n '$namespace' -o yaml" "$workloads_dir/jobs.yaml" "Job details"
    safe_exec "kubectl get cronjobs -n '$namespace'" "$workloads_dir/cronjobs.txt" "CronJobs list"
    safe_exec "kubectl get cronjobs -n '$namespace' -o yaml" "$workloads_dir/cronjobs.yaml" "CronJob details"
}

collect_networking_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting networking resources..."
    
    local network_dir="$resources_dir/networking"
    ensure_directory "$network_dir"
    
    # Services
    safe_exec "kubectl get services -n '$namespace'" "$network_dir/services.txt" "Services list"
    safe_exec "kubectl get services -n '$namespace' -o yaml" "$network_dir/services.yaml" "Service details"
    safe_exec "kubectl describe services -n '$namespace'" "$network_dir/services-describe.txt" "Service descriptions"
    
    # Endpoints
    safe_exec "kubectl get endpoints -n '$namespace'" "$network_dir/endpoints.txt" "Endpoints list"
    safe_exec "kubectl get endpoints -n '$namespace' -o yaml" "$network_dir/endpoints.yaml" "Endpoint details"
    
    # Ingress
    safe_exec "kubectl get ingress -n '$namespace'" "$network_dir/ingress.txt" "Ingress list"
    safe_exec "kubectl get ingress -n '$namespace' -o yaml" "$network_dir/ingress.yaml" "Ingress details"
    safe_exec "kubectl describe ingress -n '$namespace'" "$network_dir/ingress-describe.txt" "Ingress descriptions"
    
    # Network Policies
    safe_exec "kubectl get networkpolicies -n '$namespace'" "$network_dir/networkpolicies.txt" "Network Policies list"
    safe_exec "kubectl get networkpolicies -n '$namespace' -o yaml" "$network_dir/networkpolicies.yaml" "Network Policy details"
    
    # OpenShift Routes (if available)
    if command_exists oc; then
        safe_exec "oc get routes -n '$namespace'" "$network_dir/routes.txt" "OpenShift Routes list"
        safe_exec "oc get routes -n '$namespace' -o yaml" "$network_dir/routes.yaml" "Route details"
        safe_exec "oc describe routes -n '$namespace'" "$network_dir/routes-describe.txt" "Route descriptions"
    fi
}

collect_configuration_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting configuration resources..."
    
    local config_dir="$resources_dir/configuration"
    ensure_directory "$config_dir"
    
    # ConfigMaps
    safe_exec "kubectl get configmaps -n '$namespace'" "$config_dir/configmaps.txt" "ConfigMaps list"
    safe_exec "kubectl describe configmaps -n '$namespace'" "$config_dir/configmaps-describe.txt" "ConfigMap descriptions"
    
    # Get ConfigMap data (but be careful about size)
    kubectl get configmaps -n "$namespace" -o name 2>/dev/null | while IFS= read -r cm; do
        if [[ -n "$cm" ]]; then
            local cm_name=$(basename "$cm")
            log_debug "Collecting ConfigMap: $cm_name"
            safe_exec "kubectl get '$cm' -n '$namespace' -o yaml" "$config_dir/configmaps/${cm_name}.yaml" "ConfigMap data for $cm_name"
        fi
    done
    
    # Secrets (metadata only, no actual secret data)
    safe_exec "kubectl get secrets -n '$namespace'" "$config_dir/secrets-list.txt" "Secrets list"
    safe_exec "kubectl describe secrets -n '$namespace'" "$config_dir/secrets-describe.txt" "Secret descriptions"
    
    # Get secret metadata only (remove data section)
    kubectl get secrets -n "$namespace" -o name 2>/dev/null | while IFS= read -r secret; do
        if [[ -n "$secret" ]]; then
            local secret_name=$(basename "$secret")
            log_debug "Collecting Secret metadata: $secret_name"
            if safe_exec "kubectl get '$secret' -n '$namespace' -o yaml" "$config_dir/secrets/${secret_name}-metadata.yaml" "Secret metadata for $secret_name"; then
                # Remove actual data for security
                sed -i '/^data:/,$d' "$config_dir/secrets/${secret_name}-metadata.yaml" 2>/dev/null || true
                echo "data: <REDACTED_FOR_SECURITY>" >> "$config_dir/secrets/${secret_name}-metadata.yaml"
            fi
        fi
    done
}

collect_storage_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting storage resources..."
    
    local storage_dir="$resources_dir/storage"
    ensure_directory "$storage_dir"
    
    # Persistent Volume Claims
    safe_exec "kubectl get pvc -n '$namespace'" "$storage_dir/pvcs.txt" "PVCs list"
    safe_exec "kubectl get pvc -n '$namespace' -o yaml" "$storage_dir/pvcs.yaml" "PVC details"
    safe_exec "kubectl describe pvc -n '$namespace'" "$storage_dir/pvcs-describe.txt" "PVC descriptions"
    
    # Get related Persistent Volumes
    kubectl get pvc -n "$namespace" -o jsonpath='{.items[*].spec.volumeName}' 2>/dev/null | tr ' ' '\n' | while IFS= read -r pv_name; do
        if [[ -n "$pv_name" ]]; then
            log_debug "Collecting PV information: $pv_name"
            safe_exec "kubectl get pv '$pv_name' -o yaml" "$storage_dir/pv-${pv_name}.yaml" "PV details for $pv_name"
            safe_exec "kubectl describe pv '$pv_name'" "$storage_dir/pv-${pv_name}-describe.txt" "PV description for $pv_name"
        fi
    done
    
    # Volume Snapshots (if available)
    if kubectl api-resources | grep -q volumesnapshot; then
        safe_exec "kubectl get volumesnapshot -n '$namespace'" "$storage_dir/volume-snapshots.txt" "Volume Snapshots"
        safe_exec "kubectl get volumesnapshot -n '$namespace' -o yaml" "$storage_dir/volume-snapshots.yaml" "Volume Snapshot details"
    fi
}

collect_rbac_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting RBAC resources..."
    
    local rbac_dir="$resources_dir/rbac"
    ensure_directory "$rbac_dir"
    
    # Service Accounts
    safe_exec "kubectl get serviceaccounts -n '$namespace'" "$rbac_dir/serviceaccounts.txt" "Service Accounts list"
    safe_exec "kubectl get serviceaccounts -n '$namespace' -o yaml" "$rbac_dir/serviceaccounts.yaml" "Service Account details"
    safe_exec "kubectl describe serviceaccounts -n '$namespace'" "$rbac_dir/serviceaccounts-describe.txt" "Service Account descriptions"
    
    # Roles
    safe_exec "kubectl get roles -n '$namespace'" "$rbac_dir/roles.txt" "Roles list"
    safe_exec "kubectl get roles -n '$namespace' -o yaml" "$rbac_dir/roles.yaml" "Role details"
    safe_exec "kubectl describe roles -n '$namespace'" "$rbac_dir/roles-describe.txt" "Role descriptions"
    
    # Role Bindings
    safe_exec "kubectl get rolebindings -n '$namespace'" "$rbac_dir/rolebindings.txt" "Role Bindings list"
    safe_exec "kubectl get rolebindings -n '$namespace' -o yaml" "$rbac_dir/rolebindings.yaml" "Role Binding details"
    safe_exec "kubectl describe rolebindings -n '$namespace'" "$rbac_dir/rolebindings-describe.txt" "Role Binding descriptions"
    
    # Check for related ClusterRoles and ClusterRoleBindings
    safe_exec "kubectl get clusterroles | grep -E '(rhdh|backstage)'" "$rbac_dir/related-clusterroles.txt" "Related Cluster Roles" || echo "No related cluster roles found" > "$rbac_dir/related-clusterroles.txt"
    safe_exec "kubectl get clusterrolebindings | grep -E '(rhdh|backstage)'" "$rbac_dir/related-clusterrolebindings.txt" "Related Cluster Role Bindings" || echo "No related cluster role bindings found" > "$rbac_dir/related-clusterrolebindings.txt"
}

collect_custom_resources() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting custom resources..."
    
    local cr_dir="$resources_dir/custom-resources"
    ensure_directory "$cr_dir"
    
    # Get all custom resources in the namespace
    kubectl api-resources --namespaced=true --verbs=list -o name 2>/dev/null | while IFS= read -r resource; do
        if [[ -n "$resource" ]] && [[ "$resource" == *.* ]]; then
            log_debug "Checking custom resource: $resource"
            if kubectl get "$resource" -n "$namespace" --no-headers 2>/dev/null | grep -q .; then
                local resource_name=$(echo "$resource" | tr '/' '-' | tr '.' '-')
                safe_exec "kubectl get '$resource' -n '$namespace'" "$cr_dir/${resource_name}.txt" "Custom resource: $resource"
                safe_exec "kubectl get '$resource' -n '$namespace' -o yaml" "$cr_dir/${resource_name}.yaml" "Custom resource details: $resource"
            fi
        fi
    done
}

collect_resource_usage() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Collecting resource usage information..."
    
    local usage_dir="$resources_dir/usage"
    ensure_directory "$usage_dir"
    
    # Pod resource usage (if metrics server is available)
    safe_exec "kubectl top pods -n '$namespace'" "$usage_dir/pod-usage.txt" "Pod resource usage" || log_warn "Metrics server might not be available"
    safe_exec "kubectl top pods -n '$namespace' --containers" "$usage_dir/container-usage.txt" "Container resource usage" || log_warn "Metrics server might not be available"
    
    # Resource requests and limits
    kubectl get pods -n "$namespace" -o name 2>/dev/null | while IFS= read -r pod; do
        if [[ -n "$pod" ]]; then
            local pod_name=$(basename "$pod")
            safe_exec "kubectl get '$pod' -n '$namespace' -o jsonpath='{.spec.containers[*].resources}'" "$usage_dir/${pod_name}-resources.json" "Resource specs for $pod_name"
        fi
    done
    
    # Namespace resource quota usage
    safe_exec "kubectl describe namespace '$namespace'" "$usage_dir/namespace-describe.txt" "Namespace description"
    if kubectl get resourcequota -n "$namespace" --no-headers 2>/dev/null | grep -q .; then
        safe_exec "kubectl describe resourcequota -n '$namespace'" "$usage_dir/resourcequota-usage.txt" "Resource quota usage"
    fi
}

# Namespace-specific collection functions (using MUST_GATHER_DIR_RESOURCES if set)
collect_all_namespace_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    collect_all_namespace_resources "$namespace"
}

collect_workload_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    # Override the resources_dir in the original function by temporarily changing MUST_GATHER_DIR
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_workload_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_networking_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_networking_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_configuration_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_configuration_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_storage_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_storage_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_rbac_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_rbac_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_custom_resources_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_custom_resources "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

collect_resource_usage_ns() {
    local namespace="$1"
    local resources_dir="${MUST_GATHER_DIR_RESOURCES:-$MUST_GATHER_DIR/rhdh/resources}"
    
    local original_must_gather_dir="$MUST_GATHER_DIR"
    export MUST_GATHER_DIR="$(dirname "$resources_dir")"
    collect_resource_usage "$namespace"
    export MUST_GATHER_DIR="$original_must_gather_dir"
}

generate_resources_summary() {
    local namespace="$1"
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Generating resources collection summary..."
    
    # Count various resource types
    local pods_count=$(kubectl get pods -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
    local services_count=$(kubectl get services -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
    local configmaps_count=$(kubectl get configmaps -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
    local secrets_count=$(kubectl get secrets -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
    local pvcs_count=$(kubectl get pvc -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
    
    cat > "$resources_dir/collection-summary.txt" << EOF
RHDH Resources Collection Summary
================================
Collection Time: $(date)
Namespace: $namespace

Resource Counts:
- Pods: $pods_count
- Services: $services_count
- ConfigMaps: $configmaps_count
- Secrets: $secrets_count
- PVCs: $pvcs_count

Collected Categories:
- Workload resources (Deployments, Pods, etc.)
- Networking resources (Services, Ingress, etc.)
- Configuration resources (ConfigMaps, Secrets metadata)
- Storage resources (PVCs, PVs)
- RBAC resources (ServiceAccounts, Roles, etc.)
- Custom resources
- Resource usage information

Files Created:
$(find "$resources_dir" -type f 2>/dev/null | wc -l) files in rhdh/resources directory

Security Notes:
- Secret data has been redacted for security
- Only metadata and structure of secrets are included
- ConfigMap data is included (may contain configuration details)
EOF
}

# Generate summary for multiple namespaces
generate_resources_summary_multi_namespace() {
    local namespaces=("$@")
    local resources_dir="$MUST_GATHER_DIR/rhdh/resources"
    
    log_info "Generating multi-namespace resources collection summary..."
    
    local total_pods=0
    local total_services=0
    local total_configmaps=0
    local total_secrets=0
    local total_pvcs=0
    local total_namespaces=${#namespaces[@]}
    
    cat > "$resources_dir/collection-summary.txt" << EOF
RHDH Resources Collection Summary - Multiple Namespaces
======================================================
Collection Time: $(date)
Total RHDH Namespaces: $total_namespaces

=== NAMESPACE BREAKDOWN ===
EOF
    
    for namespace in "${namespaces[@]}"; do
        local pods_count=$(kubectl get pods -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
        local services_count=$(kubectl get services -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
        local configmaps_count=$(kubectl get configmaps -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
        local secrets_count=$(kubectl get secrets -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
        local pvcs_count=$(kubectl get pvc -n "$namespace" --no-headers 2>/dev/null | wc -l || echo "0")
        
        ((total_pods += pods_count))
        ((total_services += services_count))
        ((total_configmaps += configmaps_count))
        ((total_secrets += secrets_count))
        ((total_pvcs += pvcs_count))
        
        cat >> "$resources_dir/collection-summary.txt" << EOF

Namespace: $namespace
- Pods: $pods_count
- Services: $services_count
- ConfigMaps: $configmaps_count
- Secrets: $secrets_count
- PVCs: $pvcs_count
EOF
    done
    
    cat >> "$resources_dir/collection-summary.txt" << EOF

=== OVERALL TOTALS ===
- Total Pods: $total_pods
- Total Services: $total_services
- Total ConfigMaps: $total_configmaps
- Total Secrets: $total_secrets
- Total PVCs: $total_pvcs

=== COLLECTED CATEGORIES ===
For each namespace:
- Workload resources (Deployments, Pods, etc.)
- Networking resources (Services, Ingress, etc.)
- Configuration resources (ConfigMaps, Secrets metadata)
- Storage resources (PVCs, PVs)
- RBAC resources (ServiceAccounts, Roles, etc.)
- Custom resources
- Resource usage information

=== FILE ORGANIZATION ===
rhdh/resources/
$(for ns in "${namespaces[@]}"; do echo "├── $ns/                   # Resources from namespace $ns"; done)
└── collection-summary.txt  # This summary file

Files Created: $(find "$resources_dir" -type f 2>/dev/null | wc -l) files in rhdh/resources directory

=== SECURITY NOTES ===
- Secret data has been redacted for security
- Only metadata and structure of secrets are included
- ConfigMap data is included (may contain configuration details)
- Each namespace's data is organized in separate subdirectories
EOF
}

# Main execution
main() {
    log_info "Starting RHDH resources collection..."
    
    if ! check_cluster_connectivity; then
        log_error "Cannot connect to cluster"
        exit 1
    fi
    
    # Load detection results and get all RHDH namespaces
    load_detection_results
    local rhdh_namespaces
    mapfile -t rhdh_namespaces < <(get_rhdh_namespaces)
    
    if [[ ${#rhdh_namespaces[@]} -eq 0 ]]; then
        log_warn "No RHDH namespaces detected, skipping resource collection"
        ensure_directory "$MUST_GATHER_DIR/rhdh/resources"
        cat > "$MUST_GATHER_DIR/rhdh/resources/no-namespace-detected.txt" << EOF
RHDH Resources Collection - No Namespace Detected
================================================
Collection Time: $(date)

No RHDH namespace was detected during the discovery phase.
Cannot collect RHDH-specific resources.

Possible reasons:
- RHDH is not deployed in this cluster
- RHDH is deployed with non-standard names/labels
- Detection scripts failed to identify the deployment

Recommendation: 
- Verify RHDH is deployed and running
- Check if RHDH is in a custom namespace
- Run detection scripts manually if needed
EOF
        exit 1
    fi
    
    log_info "Found ${#rhdh_namespaces[@]} RHDH namespace(s) to collect resources from"
    
    # Collect resources from each namespace
    for namespace in "${rhdh_namespaces[@]}"; do
        if [[ -n "$namespace" ]]; then
            log_info "Collecting resources from RHDH namespace: $namespace"
            
            # Create namespace-specific subdirectory
            local ns_resources_dir="$MUST_GATHER_DIR/rhdh/resources/$namespace"
            ensure_directory "$ns_resources_dir"
            
            # Temporarily override the base resources directory for this namespace
            local original_resources_dir="$MUST_GATHER_DIR/rhdh/resources"
            export MUST_GATHER_DIR_RESOURCES="$ns_resources_dir"
            
            # Collect all categories of resources for this namespace
            collect_all_namespace_resources_ns "$namespace"
            collect_workload_resources_ns "$namespace"
            collect_networking_resources_ns "$namespace"
            collect_configuration_resources_ns "$namespace"
            collect_storage_resources_ns "$namespace"
            collect_rbac_resources_ns "$namespace"
            collect_custom_resources_ns "$namespace"
            collect_resource_usage_ns "$namespace"
            
            # Restore original resources directory
            unset MUST_GATHER_DIR_RESOURCES
        fi
    done
    
    # Generate overall summary for all namespaces
    generate_resources_summary_multi_namespace "${rhdh_namespaces[@]}"
    
    log_success "RHDH resources collection completed for ${#rhdh_namespaces[@]} namespace(s)"
}

# Show help
show_help() {
    cat << EOF
RHDH Resources Collection Script

Usage: $0 [OPTIONS]

This script collects all resources from the RHDH namespace.

Options:
  -h, --help    Show this help message

Environment Variables:
  MUST_GATHER_DIR   Output directory (default: /must-gather)
  LOG_LEVEL         Logging level (default: INFO)

Prerequisites:
  - RHDH_NAMESPACE must be set in detection results

Collected Information:
  - All namespace resources overview
  - Workload resources (Deployments, Pods, etc.)
  - Networking resources (Services, Ingress, etc.)
  - Configuration resources (ConfigMaps, Secrets metadata)
  - Storage resources (PVCs, PVs)
  - RBAC resources (ServiceAccounts, Roles, etc.)
  - Custom resources
  - Resource usage information

Examples:
  $0                # Collect RHDH resources
  LOG_LEVEL=DEBUG $0 # Collect with debug logging

Output:
  - Creates rhdh/resources/ directory with collected data
  - Generates collection-summary.txt with details

Security:
  - Secret data is redacted for security
  - Only metadata and structure of secrets are collected
EOF
}

# Handle command line arguments
if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
    show_help
    exit 0
fi

# Execute main function
main "$@"