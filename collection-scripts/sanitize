#!/usr/bin/env bash

# RHDH Must-Gather Data Sanitization Script
# Removes sensitive information from collected data while preserving diagnostic value

set -uo pipefail

# Get script directory for calling other scripts
DIR_NAME=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
source "${DIR_NAME}/common.sh"

SANITIZE_DIR="${1:-${BASE_COLLECTION_PATH}}"
SANITIZATION_REPORT="${SANITIZE_DIR}/sanitization-report.txt"

log_info "Starting data sanitization on directory: $SANITIZE_DIR"

# Counter for tracking sanitization
files_processed=0
items_sanitized=0

# Function to sanitize YAML/JSON files
sanitize_structured_file() {
    local file="$1"
    local sanitized=false

    log_debug "--> sanitizing structured file: $file"
    
    # Kubernetes Secret data sanitization
    if grep -q "kind:\s*Secret" "$file" 2>/dev/null; then
        log_debug "Sanitizing Secret data in: $file"
        # Use sed for direct in-place sanitization of Secret data values
        # This handles both root-level secrets and indented secrets (from lists/oc adm inspect)
        # Pattern 1: Root-level data fields (^data:) - data items at exactly 2 spaces
        sed -i '/^data:/,/^[a-zA-Z]/ { /^  [a-zA-Z0-9_.-]\+: / s/: .*/: [REDACTED]/ }' "$file"
        # Pattern 2: Indented data fields - for list items where data: is at 2 spaces, items at 4+ spaces
        # Match from "  data:" to next field at same or less indentation, but only replace lines with 4+ spaces
        sed -i '/^  data:/,/^  [a-zA-Z]/ { /^    [a-zA-Z0-9_.-]\+: / s/: .*/: [REDACTED]/ }' "$file"
        # Pattern 3: Even more deeply nested (e.g., 4 space base indent) - data items at 8+ spaces
        sed -i '/^    data:/,/^    [a-zA-Z]/ { /^        [a-zA-Z0-9_.-]\+: / s/: .*/: [REDACTED]/ }' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
        log_debug "Secret sanitization completed for: $file"
    fi
    
    # Base64 encoded data (common in ConfigMaps and Secrets) - skip if we already processed Secrets
    # Only match longer base64 strings that are likely to be sensitive data (40+ chars with proper base64 ending)
    if ! grep -q "kind:\s*Secret" "$file" 2>/dev/null; then
        if grep -qP '^\s+[a-zA-Z0-9_-]+:\s*["\047]?[A-Za-z0-9+/]{40,}={0,2}["\047]?\s*$' "$file" 2>/dev/null; then
            log_debug "Sanitizing base64 data in: $file"
            sed -i -E 's/^(\s+[a-zA-Z0-9_-]+:\s*["\047]?)[A-Za-z0-9+\/]{40,}={0,2}(["\047]?\s*)$/\1[REDACTED - Base64 data removed]\2/' "$file"
            sanitized=true
            items_sanitized=$((items_sanitized + 1))
            log_debug "SANITIZED: $file"
        fi
    fi
    
    # JWT tokens - more precise pattern to avoid false matches
    if grep -qP '(^|\s|["\''])ey[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]*($|\s|["\''])' "$file" 2>/dev/null; then
        log_debug "Sanitizing JWT tokens in: $file"
        sed -i -E 's/(^|\s|["\''])ey[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]*($|\s|["\''])/\1[REDACTED-JWT-TOKEN]\2/g' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    # Bearer tokens
    if grep -qi "bearer\s\+[a-zA-Z0-9_-]\{10,\}" "$file" 2>/dev/null; then
        log_debug "Sanitizing bearer tokens in: $file"
        sed -i -E 's/(bearer\s+)[a-zA-Z0-9_-]{10,}/\1[REDACTED-BEARER-TOKEN]/gi' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    # SSH private keys
    if grep -q "BEGIN.*PRIVATE KEY" "$file" 2>/dev/null; then
        log_debug "Sanitizing SSH private keys in: $file"
        sed -i '/-----BEGIN.*PRIVATE KEY-----/,/-----END.*PRIVATE KEY-----/c\
# [REDACTED - SSH Private Key Removed]' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    files_processed=$((files_processed + 1))
}

# Function to sanitize plain text files (logs, etc.)
sanitize_text_file() {
    local file="$1"
    local sanitized=false

    log_debug "--> sanitizing text file: $file"

    # JWT tokens in logs - more precise pattern to avoid false matches
    if grep -qP '(^|\s|["\''])ey[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]*($|\s|["\''])' "$file" 2>/dev/null; then
        log_debug "Sanitizing JWT tokens in log: $file"
        sed -i -E 's/(^|\s|["\''])ey[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]*($|\s|["\''])/\1[REDACTED-JWT-TOKEN]\2/g' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    # Bearer tokens in logs
    if grep -qi "authorization:\s*bearer\s\+[a-zA-Z0-9_-]\{10,\}" "$file" 2>/dev/null; then
        log_debug "Sanitizing authorization headers in log: $file"
        sed -i -E 's/(authorization:\s*bearer\s+)[a-zA-Z0-9_-]{10,}/\1[REDACTED-TOKEN]/gi' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    # Password parameters in URLs/logs
    if grep -qiP '(password|pwd|secret)=[-a-zA-Z0-9_%]+' "$file" 2>/dev/null; then
        log_debug "Sanitizing password parameters in log: $file"
        sed -i -E 's/(password|pwd|secret)=[-a-zA-Z0-9_%]+/\1=[REDACTED]/gi' "$file"
        sanitized=true
        items_sanitized=$((items_sanitized + 1))
        log_debug "SANITIZED: $file"
    fi
    
    files_processed=$((files_processed + 1))
}

# Main sanitization function
sanitize_directory() {
    local dir="$1"
    
    if [[ ! -d "$dir" ]]; then
        log_warn "Directory does not exist: $dir"
        return 1
    fi
    
    log_info "Sanitizing directory: $dir"
    
    # Find and sanitize YAML/JSON files
    while IFS= read -r -d '' file; do
        sanitize_structured_file "$file"
    done < <(find "$dir" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) -print0 2>/dev/null || true)
    
    # Find and sanitize text files (logs, etc.)
    while IFS= read -r -d '' file; do
        sanitize_text_file "$file"
    done < <(find "$dir" -type f \( -name "*.txt" -o -name "*.log" \) -print0 2>/dev/null || true)
}

if [[ ! -d "$SANITIZE_DIR" ]]; then
    log_error "Target directory to sanitize does not exist: $SANITIZE_DIR"
    exit 1
fi

# Initialize sanitization report
cat > "$SANITIZATION_REPORT" <<EOF
RHDH Must-Gather Data Sanitization Report
Generated: $(date)
Target Directory: $SANITIZE_DIR

This report details what sensitive information was sanitized from the collected data.

SANITIZATION RULES APPLIED:
- Kubernetes Secret data values
- Base64 encoded sensitive data
- JWT tokens and bearer tokens
- Passwords and API keys
- Database connection strings
- URLs with embedded credentials
- SSH keys and certificates
- OAuth tokens and client secrets
EOF

# Start sanitization
sanitize_directory "$SANITIZE_DIR"

# Write summary to report
{
    echo ""
    echo "SANITIZATION SUMMARY:"
    echo "- Files processed: $files_processed"
    echo "- Items sanitized: $items_sanitized"
    echo ""
    echo "IMPORTANT: Please review the sanitized files before sharing externally to ensure"
    echo "all sensitive information has been properly redacted."
} >> "$SANITIZATION_REPORT"

log_success "Sanitization complete!"
log_info "Files processed: $files_processed"
log_info "Items sanitized: $items_sanitized"
log_info "Report saved to: $SANITIZATION_REPORT"
