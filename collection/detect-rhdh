#!/bin/bash

# RHDH Deployment Detection Script
# Detects RHDH deployment type (Helm or Operator) and namespace

set -euo pipefail

# Source utilities
source "$(dirname "$0")/lib/utils.sh"

# Common namespaces where RHDH might be deployed (used as starting point)
declare -a COMMON_NAMESPACES=(
    "rhdh"
    "backstage" 
    "developer-hub"
    "openshift-developer-hub"
    "rhdh-operator"
    "backstage-system"
    "redhat-developer-hub"
    "backstage-operator"
    "janus-idp"
)

# Structure to hold multiple RHDH deployments
declare -a RHDH_INSTANCES=()

# Add an RHDH instance to our list
add_rhdh_instance() {
    local namespace="$1"
    local deployment_type="$2"
    local details="$3"
    
    RHDH_INSTANCES+=("$namespace:$deployment_type:$details")
    log_success "Found $deployment_type-based RHDH deployment in namespace: $namespace"
}

# Comprehensive Helm deployment detection
detect_helm_deployments_comprehensive() {
    log_info "Searching for Helm-based RHDH deployments across all namespaces..."
    
    # Initialize temp file
    : > /tmp/rhdh_instances.tmp
    
    # Method 1: Look for Helm release secrets directly 
    log_debug "Searching for Helm release secrets..."
    local helm_secrets
    helm_secrets=$(kubectl get secret --all-namespaces -l "owner=helm" -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)
    
    if [[ -n "$helm_secrets" ]]; then
        echo "$helm_secrets" | while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local namespace=$(echo "$line" | awk '{print $1}')
                local secret_name=$(echo "$line" | awk '{print $2}')
                
                # Check if it's a Helm release secret and extract release name
                if [[ "$secret_name" == sh.helm.release.v*.v* ]]; then
                    local release_name=$(echo "$secret_name" | sed 's/sh\.helm\.release\.v[0-9]*\.\(.*\)\.v[0-9]*/\1/')
                    
                    # Check if release name contains RHDH/Backstage patterns
                    if [[ "$release_name" =~ (backstage|rhdh|developer-hub|janus) ]]; then
                        echo "$namespace:helm:release=$release_name" >> /tmp/rhdh_instances.tmp
                        log_debug "Found Helm release: $release_name in namespace: $namespace"
                    fi
                fi
            fi
        done
    fi
    
    # Method 2: Search through application secrets with Helm management
    log_debug "Searching through application secrets..."
    local app_secrets
    app_secrets=$(kubectl get secret --all-namespaces -l "app.kubernetes.io/managed-by=Helm" -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{" "}{.metadata.annotations.meta\.helm\.sh/release-name}{"\n"}{end}' 2>/dev/null || true)
    
    if [[ -n "$app_secrets" ]]; then
        echo "$app_secrets" | while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local namespace=$(echo "$line" | awk '{print $1}')
                local secret_name=$(echo "$line" | awk '{print $2}')
                local release_name=$(echo "$line" | awk '{print $3}')
                
                # Check if the release name or secret name contains RHDH/Backstage patterns
                if [[ "$secret_name" =~ (backstage|rhdh|developer-hub|janus) ]] || [[ "$release_name" =~ (backstage|rhdh|developer-hub|janus) ]]; then
                    if [[ -n "$release_name" ]]; then
                        echo "$namespace:helm:release=$release_name" >> /tmp/rhdh_instances.tmp
                        log_debug "Found Helm release from secret: $release_name in namespace: $namespace"
                    fi
                fi
            fi
        done
    fi
    
    # Method 3: Look for RHDH pods with Helm labels
    log_debug "Searching for RHDH pods with Helm management..."
    local helm_pods
    helm_pods=$(kubectl get pods --all-namespaces -l "app.kubernetes.io/managed-by=Helm" -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{" "}{.metadata.labels.app\.kubernetes\.io/instance}{"\n"}{end}' 2>/dev/null || true)
    
    if [[ -n "$helm_pods" ]]; then
        echo "$helm_pods" | while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local namespace=$(echo "$line" | awk '{print $1}')
                local pod_name=$(echo "$line" | awk '{print $2}')
                local instance_name=$(echo "$line" | awk '{print $3}')
                
                # Check for Backstage/RHDH patterns in pod or instance name
                if [[ "$pod_name" =~ (backstage|rhdh|developer-hub|janus) ]] || [[ "$instance_name" =~ (backstage|rhdh|developer-hub|janus) ]]; then
                    if [[ -n "$instance_name" ]]; then
                        echo "$namespace:helm:release=$instance_name" >> /tmp/rhdh_instances.tmp
                        log_debug "Found Helm instance from pod: $instance_name in namespace: $namespace"
                    fi
                fi
            fi
        done
    fi
    
    # Count found instances from temp file
    local found=0
    if [[ -f /tmp/rhdh_instances.tmp ]]; then
        found=$(grep -c ":helm:" /tmp/rhdh_instances.tmp 2>/dev/null || echo "0")
    fi
    
    log_debug "Helm detection completed. Found: $found instances"
    return 0
}

# Comprehensive Operator deployment detection
detect_operator_deployments_comprehensive() {
    log_info "Searching for Operator-based RHDH deployments across all namespaces..."
    
    # Method 1: Look for Backstage Custom Resources
    log_debug "Searching for Backstage Custom Resources..."
    if kubectl api-resources | grep -q backstage; then
        local backstage_crs
        backstage_crs=$(kubectl get backstages --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)
        
        if [[ -n "$backstage_crs" ]]; then
            echo "$backstage_crs" | while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                    local namespace=$(echo "$line" | awk '{print $1}')
                    local cr_name=$(echo "$line" | awk '{print $2}')
                    echo "$namespace:operator:backstage-cr=$cr_name" >> /tmp/rhdh_instances.tmp
                    log_debug "Found Backstage CR: $cr_name in namespace: $namespace"
                fi
            done
        fi
    fi
    
    # Method 2: Look for RHDH Operator deployments
    log_debug "Searching for RHDH Operator deployments..."
    local operator_deployments
    operator_deployments=$(kubectl get deployments --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)
    
    if [[ -n "$operator_deployments" ]]; then
        echo "$operator_deployments" | while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local namespace=$(echo "$line" | awk '{print $1}')
                local deployment_name=$(echo "$line" | awk '{print $2}')
                
                # Look for operator patterns
                if [[ "$deployment_name" =~ (rhdh.*operator|backstage.*operator|.*controller.*manager) ]]; then
                    # Additional check to confirm it's RHDH-related
                    if kubectl get deployment "$deployment_name" -n "$namespace" -o yaml 2>/dev/null | grep -q -E "(backstage|rhdh|developer-hub|janus)"; then
                        echo "$namespace:operator:operator-deployment=$deployment_name" >> /tmp/rhdh_instances.tmp
                        log_debug "Found Operator deployment: $deployment_name in namespace: $namespace"
                    fi
                fi
            fi
        done
    fi
    
    # Method 3: Look for RHDH-related CSVs (ClusterServiceVersions)
    log_debug "Searching for RHDH-related CSVs..."
    if kubectl api-resources 2>/dev/null | grep -q clusterserviceversion; then
        local csvs
        csvs=$(kubectl get csv --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)
        
        if [[ -n "$csvs" ]]; then
            echo "$csvs" | while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                    local namespace=$(echo "$line" | awk '{print $1}')
                    local csv_name=$(echo "$line" | awk '{print $2}')
                    
                    if [[ "$csv_name" =~ (rhdh|backstage|developer-hub|janus) ]]; then
                        echo "$namespace:operator:csv=$csv_name" >> /tmp/rhdh_instances.tmp
                        log_debug "Found CSV: $csv_name in namespace: $namespace"
                    fi
                fi
            done
        fi
    fi
    
    # Count found instances from temp file
    local found=0
    if [[ -f /tmp/rhdh_instances.tmp ]]; then
        found=$(grep -c ":operator:" /tmp/rhdh_instances.tmp 2>/dev/null || echo "0")
    fi
    
    log_debug "Operator detection completed. Found: $found instances"
    return 0
}

# Process and deduplicate found instances
process_rhdh_instances() {
    if [[ ! -f /tmp/rhdh_instances.tmp ]]; then
        return 1
    fi
    
    log_info "Processing detected RHDH instances..."
    
    # Read instances into a temporary array to avoid subshell issues
    local temp_instances
    mapfile -t temp_instances < <(sort /tmp/rhdh_instances.tmp | uniq)
    
    # Process each instance
    for instance in "${temp_instances[@]}"; do
        if [[ -n "$instance" ]]; then
            local namespace=$(echo "$instance" | cut -d':' -f1)
            local deployment_type=$(echo "$instance" | cut -d':' -f2)
            local details=$(echo "$instance" | cut -d':' -f3-)
            
            add_rhdh_instance "$namespace" "$deployment_type" "$details"
        fi
    done
    
    # Clean up temp file
    rm -f /tmp/rhdh_instances.tmp
    
    return 0
}

# Save all detected instances
save_detection_results() {
    local primary_namespace=""
    local primary_type=""
    local total_instances=${#RHDH_INSTANCES[@]}
    
    if [[ $total_instances -eq 0 ]]; then
        write_detection_result "DEPLOYMENT_TYPE" "none"
        write_detection_result "RHDH_NAMESPACE" ""
        write_detection_result "RHDH_INSTANCES_COUNT" "0"
        return 1
    fi
    
    # Use the first instance as primary
    local first_instance="${RHDH_INSTANCES[0]}"
    primary_namespace=$(echo "$first_instance" | cut -d':' -f1)
    primary_type=$(echo "$first_instance" | cut -d':' -f2)
    
    # Save primary instance info (for backward compatibility)
    write_detection_result "DEPLOYMENT_TYPE" "$primary_type"
    write_detection_result "RHDH_NAMESPACE" "$primary_namespace"
    
    # Set a basic cluster type for compatibility (can be detected from kubectl version if needed)
    if kubectl version -o json 2>/dev/null | grep -q '"gitVersion".*"openshift"'; then
        write_detection_result "CLUSTER_TYPE" "openshift"
    else
        write_detection_result "CLUSTER_TYPE" "kubernetes"
    fi
    write_detection_result "RHDH_INSTANCES_COUNT" "$total_instances"
    
    # Save all instances
    local instances_file="$MUST_GATHER_DIR/rhdh-instances.env"
    cat > "$instances_file" << EOF
# RHDH Instances Detection Results
# Format: NAMESPACE:DEPLOYMENT_TYPE:DETAILS
EOF
    
    for instance in "${RHDH_INSTANCES[@]}"; do
        echo "$instance" >> "$instances_file"
    done
    
    log_info "Detected $total_instances RHDH instance(s)"
    log_info "Primary instance: $primary_type in namespace $primary_namespace"
    
    if [[ $total_instances -gt 1 ]]; then
        log_warn "Multiple RHDH instances detected - will collect data from all instances"
    fi
    
    return 0
}

# Generate comprehensive deployment summary
generate_deployment_summary() {
    log_info "Generating deployment summary..."
    
    local details_file="$MUST_GATHER_DIR/rhdh-deployment-details.txt"
    local instances_count=${#RHDH_INSTANCES[@]}
    
    cat > "$details_file" << EOF
RHDH Deployment Detection Results
================================
Detection Time: $(date)
Total Instances Found: $instances_count

=== DETECTED INSTANCES ===
EOF
    
    local helm_count=0
    local operator_count=0
    
    for instance in "${RHDH_INSTANCES[@]}"; do
        local namespace=$(echo "$instance" | cut -d':' -f1)
        local deployment_type=$(echo "$instance" | cut -d':' -f2)
        local details=$(echo "$instance" | cut -d':' -f3-)
        
        if [[ "$deployment_type" == "helm" ]]; then
            ((helm_count++))
        elif [[ "$deployment_type" == "operator" ]]; then
            ((operator_count++))
        fi
        
        cat >> "$details_file" << EOF

Instance: $namespace ($deployment_type)
Details: $details
EOF
        
        # Add pods information for each namespace
        echo "Pods in namespace $namespace:" >> "$details_file"
        kubectl get pods -n "$namespace" -o wide >> "$details_file" 2>&1 || echo "Failed to get pods from $namespace" >> "$details_file"
        
        # Add deployment-specific details
        if [[ "$deployment_type" == "helm" ]] && command_exists helm; then
            echo "" >> "$details_file"
            echo "Helm releases in $namespace:" >> "$details_file"
            helm list -n "$namespace" >> "$details_file" 2>&1 || echo "Failed to get helm releases from $namespace" >> "$details_file"
        elif [[ "$deployment_type" == "operator" ]]; then
            echo "" >> "$details_file"
            echo "Backstage CRs in $namespace:" >> "$details_file"
            kubectl get backstage -n "$namespace" -o wide >> "$details_file" 2>&1 || echo "Failed to get Backstage CRs from $namespace" >> "$details_file"
        fi
    done
    
    cat >> "$details_file" << EOF

=== SUMMARY ===
Helm-based instances: $helm_count
Operator-based instances: $operator_count
Total instances: $instances_count

=== COLLECTION STRATEGY ===
The must-gather tool will collect data from all detected instances.
Each namespace will be processed according to its deployment type.
EOF
}

# Generate summary when no deployment is found
generate_no_deployment_summary() {
    local details_file="$MUST_GATHER_DIR/rhdh-deployment-details.txt"
    
    cat > "$details_file" << EOF
RHDH Deployment Detection Results
================================
Detection Time: $(date)
Total Instances Found: 0

=== SEARCH METHODS USED ===

1. Helm Deployment Detection:
   - Searched all namespaces for Helm secrets with Backstage/RHDH patterns
   - Used Helm CLI to list releases in all namespaces (if available)
   - Looked for Backstage/RHDH pods with Helm management labels

2. Operator Deployment Detection:
   - Searched for Backstage Custom Resources across all namespaces
   - Looked for RHDH Operator deployments and controller managers
   - Checked for RHDH-related ClusterServiceVersions (CSVs)

3. Pattern Matching:
   - backstage, rhdh, developer-hub, janus-idp patterns
   - Checked release names, chart names, pod names, and labels

=== COMMON NAMESPACES CHECKED ===
$(printf "- %s\n" "${COMMON_NAMESPACES[@]}")

=== RECOMMENDATIONS ===

If RHDH is deployed but not detected, it might be because:
1. Non-standard naming conventions are used
2. Custom labels or annotations are applied
3. RHDH is deployed with a different chart/operator name
4. Insufficient permissions to access the deployment namespace

Manual Investigation Steps:
1. Check if RHDH pods exist: kubectl get pods --all-namespaces | grep -E "(backstage|rhdh)"
2. Look for custom deployments: kubectl get deployments --all-namespaces | grep -E "(backstage|rhdh)"
3. Check for custom Helm releases: helm list --all-namespaces | grep -E "(backstage|rhdh)"
4. Verify namespace access permissions

The must-gather tool will continue with general cluster information collection.
EOF
}

detect_rhdh_deployment() {
    log_info "Detecting RHDH deployments across all namespaces..."
    
    # Initialize temp file for instances
    rm -f /tmp/rhdh_instances.tmp
    
    # Run comprehensive detection
    detect_helm_deployments_comprehensive
    detect_operator_deployments_comprehensive
    
    # Process the results
    if process_rhdh_instances; then
        save_detection_results
        generate_deployment_summary
        return 0
    else
        # No RHDH deployment found
        write_detection_result "DEPLOYMENT_TYPE" "none"
        write_detection_result "RHDH_NAMESPACE" ""
        write_detection_result "RHDH_INSTANCES_COUNT" "0"
        log_warn "No RHDH deployment detected"
        
        generate_no_deployment_summary
        return 1
    fi
}

# Main execution
main() {
    log_info "Starting RHDH deployment detection..."
    
    if ! check_cluster_connectivity; then
        log_error "Cannot connect to cluster"
        exit 1
    fi
    
    detect_rhdh_deployment
    
    # Display results
    local deployment_type=$(read_detection_result "DEPLOYMENT_TYPE")
    local namespace=$(read_detection_result "RHDH_NAMESPACE")
    
    if [[ "$deployment_type" != "none" ]]; then
        log_success "RHDH deployment detection completed"
        log_info "Type: $deployment_type, Namespace: $namespace"
    else
        log_warn "RHDH deployment detection completed - no deployment found"
    fi
}

# Show help
show_help() {
    cat << EOF
RHDH Deployment Detection Script

Usage: $0 [OPTIONS]

This script detects RHDH deployment type (Helm or Operator) and namespace.

Options:
  -h, --help    Show this help message

Environment Variables:
  MUST_GATHER_DIR   Output directory (default: /must-gather)
  LOG_LEVEL         Logging level (default: INFO)

Detection Logic:
  1. Checks common RHDH namespaces first
  2. Looks for Helm releases with backstage labels
  3. Looks for Backstage Custom Resources
  4. Falls back to searching all namespaces

Examples:
  $0                # Detect RHDH deployment
  LOG_LEVEL=DEBUG $0 # Detect with debug logging

Output:
  - Sets DEPLOYMENT_TYPE and RHDH_NAMESPACE in detection-results.env
  - Creates rhdh-deployment-details.txt with findings
EOF
}

# Handle command line arguments
if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
    show_help
    exit 0
fi

# Execute main function
main "$@"