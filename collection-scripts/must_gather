#!/usr/bin/env bash

# RHDH Must-Gather Tool - Main Orchestrator
# Collects diagnostic information for Red Hat Developer Hub troubleshooting
# Supports both OpenShift and standard Kubernetes clusters
# Handles both Helm and Operator deployments

set -euo pipefail

# Get script directory for calling other scripts
DIR_NAME=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
source "${DIR_NAME}/common.sh"

mandatory_scripts=(
  "platform"
  "helm"
  "operator"
  "route"
  "ingress"
  "namespace-inspect"
)
requested_scripts=("${mandatory_scripts[@]}")
excluded_scripts=()
target_namespaces=""
with_secrets="false"
with_heap_dumps="false"

function main() {

  parse_flags "$@"

  trap "echo 'done with data collection. Now sanitizing data...' && '${DIR_NAME}'/sanitize '${BASE_COLLECTION_PATH}' || true" EXIT

  log_info "Starting RHDH must-gather collection..."
  log_info "Output directory: $BASE_COLLECTION_PATH"
  log_info "Log level: $LOG_LEVEL"

  # generate /version file
  source "${DIR_NAME}/version"
  echo "rhdh/must-gather" > "${BASE_COLLECTION_PATH}/version"
  version >> "${BASE_COLLECTION_PATH}/version"

  # Initialize must-gather environment
  if ! init_must_gather; then
      log_error "Failed to initialize must-gather environment"
      exit 1
  fi

  run_scripts
  run_logs

  sync
  exit 0
}

function parse_flags {
  while :; do
    case ${1:-} in
      --help|-h)
        help
        exit 0
        ;;
      --cluster-info)
        requested_scripts+=("cluster-info")
        ;;
      --without-operator)
        excluded_scripts+=("operator")
        ;;
      --without-helm)
        excluded_scripts+=("helm")
        ;;
      --without-platform)
        excluded_scripts+=("platform")
        ;;
      --without-route)
        excluded_scripts+=("route")
        ;;
      --without-ingress)
        excluded_scripts+=("ingress")
        ;;
      --without-namespace-inspect)
        excluded_scripts+=("namespace-inspect")
        ;;
      --with-secrets)
        with_secrets="true"
        ;;
      --with-heap-dumps)
        with_heap_dumps="true"
        ;;
      --namespaces)
        if [[ -n "${2:-}" ]]; then
          target_namespaces="$2"
          shift
        else
          log_error "--namespaces requires a comma-separated list of namespaces"
          exit 1
        fi
        ;;
      --namespaces=*)
        target_namespaces="${1#*=}"
        ;;
      --)
        shift
        break
        ;;
      -?*)
        printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
        ;;
      *) # Default case: No more options, so break out of the loop.
        break
    esac
    shift
  done
}

function help {
    echo "\
Usage: ./$(basename "$0") [params...]

  A client tool for gathering RHDH information from Helm and Operator installations in an OpenShift or Kubernetes cluster

  Available options:

  > To see this help menu and exit, use:
  --help

  > By default, the tool collects RHDH-specific information including:"
    for collector in "${mandatory_scripts[@]}" ; do
    echo "  > - $collector"
    done
    echo "\

  > You can exclude specific data collection types:
  --without-operator            Skip operator-based RHDH deployment data collection
  --without-helm                Skip Helm-based RHDH deployment data collection  
  --without-platform            Skip platform detection and information
  --without-route               Skip OpenShift route collection
  --without-ingress             Skip Kubernetes ingress collection
  --without-namespace-inspect   Skip deep Namepace's inspect

  > You can also choose to enable optional collectors:
  --cluster-info                Collect cluster-wide diagnostic information

  > You can limit collection to specific namespaces:
  --namespaces ns1,ns2    Collect data only from specified comma-separated namespaces

  > Security and Privacy Options:
  --with-secrets                Include Kubernetes Secrets in collection (opt-in, disabled by default)
                                When disabled, secret resources are excluded from all collectors
                                When enabled, secrets are collected but automatically sanitized

  > Diagnostic and Troubleshooting Options:
  --with-heap-dumps             Collect heap dumps from running backstage-backend processes (opt-in, disabled by default)
                                Heap dumps are collected immediately after pod logs for each deployment/CR
                                Useful for troubleshooting memory leaks and performance issues
                                
                                IMPORTANT: Requires NODE_OPTIONS environment variable:
                                  NODE_OPTIONS="--heapsnapshot-signal=SIGUSR2 --diagnostic-dir=/tmp"
                                
                                Why these flags?
                                  • --heapsnapshot-signal=SIGUSR2: Built into Node.js v12.0.0+, enables heap dumps
                                  • --diagnostic-dir=/tmp: REQUIRED for read-only root filesystems
                                
                                No image rebuild or source code changes needed!
                                
                                Collection method: SIGUSR2 signal sent directly via kubectl exec
                                Works with any Kubernetes version, no special RBAC permissions needed
                                Warning: May take several minutes and generate large files (100MB-1GB+ per pod)

  Examples:
  # Default collection (includes Namepace's inspect for OMC compatibility)
  ./$(basename "$0")

  # Collect only Helm data (skip operator data)
  ./$(basename "$0") --without-operator

  # Collect only operator data (skip Helm data)
  ./$(basename "$0") --without-helm

  # Skip Namepace's inspect (not recommended - removes OMC compatibility)
  ./$(basename "$0") --without-namespace-inspect

  # Minimal collection (only platform info, no Namepace's inspect)
  ./$(basename "$0") --without-operator --without-helm --without-route --without-ingress --without-namespace-inspect

  # Collect from specific namespaces only
  ./$(basename "$0") --namespaces rhdh-prod,rhdh-staging

  # Combine namespace filtering with exclusions
  ./$(basename "$0") --namespaces my-rhdh-ns --without-operator

  # Include secrets in collection (for detailed troubleshooting - secrets will be sanitized)
  ./$(basename "$0") --with-secrets

  # Collect heap dumps for memory troubleshooting (requires app configured with NODE_OPTIONS)
  # Prerequisites: Add NODE_OPTIONS="--heapsnapshot-signal=SIGUSR2 --diagnostic-dir=/tmp" to the backsetage-backend container
  ./$(basename "$0") --with-heap-dumps

  # Full diagnostic collection (secrets + heap dumps - generates large output)
  ./$(basename "$0") --with-secrets --with-heap-dumps
"
}

function run_scripts {
  # Remove excluded scripts from the requested scripts
  for excluded in "${excluded_scripts[@]}"; do
    for i in "${!requested_scripts[@]}"; do
      if [[ "${requested_scripts[i]}" == "$excluded" ]]; then
        unset 'requested_scripts[i]'
      fi
    done
  done
  # Rebuild array to remove gaps
  requested_scripts=("${requested_scripts[@]}")

  log_info "running the following scripts: ${requested_scripts[*]}"

  # Export namespace filtering for use by collection scripts
  if [[ -n "${target_namespaces:-}" ]]; then
    export RHDH_TARGET_NAMESPACES="$target_namespaces"
    log_info "Limiting collection to namespaces: $target_namespaces"
  fi
  
  # Export secret collection flag for use by collection scripts
  export RHDH_WITH_SECRETS="${with_secrets:-}"
  if [[ "${RHDH_WITH_SECRETS}" == "true" ]]; then
    log_warn "Secret collection enabled - sensitive data will be included (and sanitized)"
  else
    log_info "Secret collection disabled by default (use --with-secrets to enable)"
  fi

  # Export heap dump collection flag
  export RHDH_WITH_HEAP_DUMPS="${with_heap_dumps:-}"
  if [[ "${RHDH_WITH_HEAP_DUMPS}" == "true" ]]; then
    log_warn "Heap dump collection enabled - this may take several minutes and generate large files"
  fi

  for script in "${requested_scripts[@]}";
  do
    script_name="gather_${script}"
    log_info "running ${script_name}"
    if ! eval "${DIR_NAME}/${script_name}"; then
      log_warn "Failed to run ${script_name}, continuing with next script..."
    fi
  done
}

function run_logs {
  log_info "running logs"
  if ! "${DIR_NAME}"/logs.sh; then
    log_warn "Failed to run logs.sh, continuing..."
  fi
}

main "$@"
